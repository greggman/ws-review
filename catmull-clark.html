<!doctype html>

<html>

<head>
  <meta charset="utf-8">
  <title>Catmull-Clark Subdivision Surfaces</title>
</head>

<body>
  <canvas width="512" height="512"></canvas>
  <script type="module">
    // from https://webgpufundamentals.org/webgpu/lessons/webgpu-fundamentals.html
    async function main() {
      const adapter = await navigator.gpu?.requestAdapter();
      const device = await adapter?.requestDevice();
      if (!device) {
        fail('Fatal error: Device does not support WebGPU.');
        return;
      }

      const module = device.createShaderModule({
        label: 'doubling compute module',
        code: /*wgsl*/`
        @group(0) @binding(0) var<storage, read_write> data: array<f32>;

        @compute @workgroup_size(1) fn computeSomething(
          @builtin(global_invocation_id) id: vec3u) {
            let i = id.x;
            data[i] = data[i] * 2.0;
        }
      `,
      });

      const pipeline = device.createComputePipeline({
        label: 'doubling compute pipeline',
        layout: 'auto',
        compute: {
          module,
        },
      });

      const base_vertices = new Uint32Array([0, 1, 2, 3, 4]);
      // note the following are float3s (x, y, z)
      const base_vertex_positions = new Float32Array([
        0, 0, 1,   // vertex 0
        -1, 1, 0,  // vertex 1
        -1, -1, 0, // vertex 2
        1, -1, 0,  // vertex 3
        1, 1, 0    // vertex 4
      ]);
      // Q: Is a flattened 1D array the right way to represent base faces?
      const base_faces = new Uint32Array([
        0, 1, 2,   // vertices in face 0
        0, 2, 3,   //         ... face 1
        0, 3, 4,   //         ... face 2
        0, 4, 1,   //         ... face 3
        4, 3, 2, 1 //         ... face 4
      ]);
      const base_valence = new Uint32Array([3, 3, 3, 3, 4]);
      // base_offset is exclusive_scan('+', base_valence)
      // TODO: compute that scan in a compute shader
      const base_offset = new Uint32Array([0, 3, 6, 9, 12]);

      // (1) Calculation of face points
      // Number of faces: base_valence.length
      // for each face: new face point = centroid(vertices of current face)
      // Pseudocode:   (note math operations are on float3s)
      // parallel for i in [0 .. base_valence.length]:
      //   new_faces[i] = [0,0,0]
      //   for j in [base_offset[i] .. base_offset[i] + base_valence[i]]:
      //     vertex_position = base_faces[j]   // get 3 floats
      //     new_faces[i] += base_vertex_positions[vertex_position]
      //   new_faces[i] /= base_valence[i]

      const input = new Float32Array([1, 3, 5]);

      // create a buffer on the GPU to hold our computation
      // input and output
      const workBuffer = device.createBuffer({
        label: 'work buffer',
        size: input.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
      });
      // Copy our input data to that buffer
      device.queue.writeBuffer(workBuffer, 0, input);

      // create a buffer on the GPU to get a copy of the results
      const resultBuffer = device.createBuffer({
        label: 'result buffer',
        size: input.byteLength,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
      });

      // Setup a bindGroup to tell the shader which
      // buffer to use for the computation
      const bindGroup = device.createBindGroup({
        label: 'bindGroup for work buffer',
        layout: pipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer: workBuffer } },
        ],
      });

      // Encode commands to do the computation
      const encoder = device.createCommandEncoder({
        label: 'doubling encoder',
      });
      const pass = encoder.beginComputePass({
        label: 'doubling compute pass',
      });
      pass.setPipeline(pipeline);
      pass.setBindGroup(0, bindGroup);
      pass.dispatchWorkgroups(input.length);
      pass.end();

      // Encode a command to copy the results to a mappable buffer.
      encoder.copyBufferToBuffer(workBuffer, 0, resultBuffer, 0, resultBuffer.size);

      // Finish encoding and submit the commands
      const commandBuffer = encoder.finish();
      device.queue.submit([commandBuffer]);

      // Read the results
      await resultBuffer.mapAsync(GPUMapMode.READ);
      const result = new Float32Array(resultBuffer.getMappedRange().slice());
      resultBuffer.unmap();

      console.log('input', input);
      console.log('result', result);
    }

    function fail(msg) {
      // eslint-disable-next-line no-alert
      alert(msg);
    }

    main();
  </script>
</body>

</html>